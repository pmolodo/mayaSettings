/* This file downloaded from Highend3d.com
''  
''  Highend3d.com File Information:
''  
''    Script Name: zenTools
''    Author:  
''    Last Updated: Feb 13, 2008
''    Update/Change this file at:
''    http://Highend3d.com/maya/downloads/mel_scripts/modeling/curve_tools/4337.html
''  
''  Please do not alter any information above this line
''  it is generated dynamically by Highend3d.com and will
''  be changed automatically on any updates.
*/
global proc int[] zenQueryFlippedEdgeRingPaths(int $global,string $edgePaths[])
{
	int	$returnVal[];
	int	$err;

	string	$edgesA[];
	string	$edgesB[];
	
	string	$a0;
	string	$a1;
	
	string	$b0;
	string	$b1;
	
	int	$edgeDistances0[];
	int	$edgeDistances1[];

	string	$endVertsA[];
	string	$endVertsB[];
	
	vector	$pointPosA0;
	vector	$pointPosA1;
	vector	$pointPosB0;
	vector	$pointPosB1;
	
	vector	$tanA;
	vector	$tanB;
	vector	$reverseA;
	
	float	$tanA_array[];
	float	$tanB_array[];
	float	$reverseA_array[];
	
	vector	$difference1;
	vector	$difference2;
	
		$returnVal[0]=0;
	
		for($i=1;$i<(size($edgePaths));$i++)
		{
			$edgesA=stringToStringArray($edgePaths[$i],",");
			$edgesB=stringToStringArray($edgePaths[($i-1)],",");
						
			if((size($edgesA))>1)
			{			
				$endVertsA=`zenFindEdgeSelectionEndVerts $edgesA`;

				$a0=zenReturnFirstStringItem
				(
					zenStringArrayIntersect
					(
						(ls("-fl",`polyListComponentConversion -tv ($edgesA[0])`)),
						(ls("-fl",`polyListComponentConversion -tv $endVertsA`))
					)
				);
				
				$a1=zenReturnFirstStringItem
				(
					zenStringArrayIntersect
					(
						(ls("-fl",`polyListComponentConversion -tv ($edgesA[(size($edgesA)-1)])`)),
						(ls("-fl",`polyListComponentConversion -tv $endVertsA`))
					)
				);
			}
			else
			{
				$a0=zenReturnFirstStringItem(ls("-fl",`polyListComponentConversion -fe -tv ($edgesA[0])`));
				$a1=zenReturnLastStringItem(ls("-fl",`polyListComponentConversion -fe -tv ($edgesA[0])`));
			}
			
			if((size($edgesB))>1)
			{			
				$endVertsB=`zenFindEdgeSelectionEndVerts $edgesB`;

				$b0=zenReturnFirstStringItem
				(
					zenStringArrayIntersect
					(
						(ls("-fl",`polyListComponentConversion -tv ($edgesB[0])`)),
						(ls("-fl",`polyListComponentConversion -tv $endVertsB`))
					)
				);
				
				$b1=zenReturnFirstStringItem
				(
					zenStringArrayIntersect
					(
						(ls("-fl",`polyListComponentConversion -tv ($edgesB[(size($edgesB)-1)])`)),
						(ls("-fl",`polyListComponentConversion -tv $endVertsB`))
					)
				);			}
			else
			{
				$b0=zenReturnFirstStringItem(ls("-fl",`polyListComponentConversion -fe -tv ($edgesB[0])`));
				$b1=zenReturnLastStringItem(ls("-fl",`polyListComponentConversion -fe -tv ($edgesB[0])`));
			}

			$edgeDistances0={0,0};
			$returnVal[$i]=0;
			
			if(!$global)
			{
				if(size(stringArrayRemoveDuplicates(`ls -o {$b0,$a0,$a1}`))==1)
				{
					$err=catch($edgeDistances0=zenEdgeDistance($b0,{$a0,$a1}));
					$err=catch($edgeDistances1=zenEdgeDistance($b1,{$a1,$a0}));
				}
					
				print "\n";print $edgeDistances0;print "\n";
				
				if($err) $edgeDistances0={0,0};
				
				if(($edgeDistances0[0]+$edgeDistances1[0])>($edgeDistances0[1]+$edgeDistances1[1]) && $returnVal[($i-1)]==0)
					$returnVal[$i]=1;
				else	
				if(($edgeDistances0[0]+$edgeDistances1[0])<($edgeDistances0[1]+$edgeDistances1[1]) && $returnVal[($i-1)]==1)
					$returnVal[$i]=1;
			}
		
			if($edgeDistances0[0]==$edgeDistances0[1] || $global)
			//if edges are on different meshes, or edge distances are equal, or $global==true
			//use tangent vector to determine if they are flipped
			{
				$pointPosA0=zenArrayToVector(`pointPosition -w $a0`);
				$pointPosA1=zenArrayToVector(`pointPosition -w $a1`);
				$pointPosB0=zenArrayToVector(`pointPosition -w $b0`);
				$pointPosB1=zenArrayToVector(`pointPosition -w $b1`);
				
				$tanA=$pointPosA1-$pointPosA0;
				$tanB=$pointPosB1-$pointPosB0;
				$reverseA=$pointPosA0=$pointPosA1;
				
				$tanA_array=zenVectorToArray($tanA);
				$tanB_array=zenVectorToArray($tanB);
				$reverseA_array=zenVectorToArray($reverseA);
				
				normalize($tanA_array);
				normalize($tanB_array);
				normalize($reverseA_array);
				
				$tanA=zenArrayToVector($tanA_array);
				$tanB=zenArrayToVector($tanB_array);
				$reverseA=zenArrayToVector($reverseA_array);

				$difference1=mag($tanA-$tanB);
				$difference2=mag($reverseA-$tanB);
				
				if($difference1>1 && $returnVal[($i-1)]==0)
					$returnVal[$i]=1;
				else
				if($difference1<1 && $returnVal[($i-1)]==1)
					$returnVal[$i]=1;
			}
			
		}
		
	return	$returnVal;
}